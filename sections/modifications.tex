\section{Modifications}
In this section we introduce some modifications to the basic protocol. First, we are going to cover conversion of our gamechannel to the version without the Dealer role with two equal players. The other modification allows connecting to the channel a third party that will not directly participate in the game but will get published channel states with participant signatures. 

\subsection{Two Players Case}
Some games (e.g., some dice variations) involve two equal players, and a casino takes no part in the process. The original protocol version covered in the \nameref{gamechannel} section, implies that one of the participants is responsible for random number generation and has to ensure a more stable connection than the other. This also allows Player to force Dealer into playing an additional round before the channel closes. To make channel participants equal, we suggest a protocol version, based on the  \textit {Threshold Signature Scheme}[][]. Obviously, the threshold signature must have the property of uniqueness. TBLS[] will be used as such signature.

Let’s redeclare the Player role as $Player1$, and the Dealer role as $Player2$. For the two player scenario an altered version of the \autoref{alg:openchannel} protocol is applied to open the channel. The RSA signature is replaced with the selected threshold signature scheme $ \tau $ with the $\tau.PartSign()$ algorithm. This algorithm takes as input a message m and outputs a  participant partial signature of the message. Item 2 is replaced with the DKG protocol that allows each party to have a part of the private key and a shared public key. Just like in the original protocol, the channel state changes to $Open$ when the channel receives two valid participant signatures. 

Once the channel is open, a round involving interaction of two peer parties takes place under the new protocol at the  \pageref{intchannel1} page. Obviously, upon completion of each round each party gets a signed game result and a signed message from the other party with the same data in it. Dispute can be initiated in the case of data discrepancy.
\begin{algorithm} 
\floatname{algorithm}{Protocol}
\caption*{\textbf{Protocol 2.1} Messaging in the channel}
\begin{enumerate}
	\item Participants generate and exchange messages of the following type:
 \label{intchannel1}
\begin{center}
$ seed\_message = (channelId, bet, round, gameData, seed)$
$signed\_seed\_message = ECDSA.Sign(seed\_message)$ 
\end{center}
	\item Participants verify the received $signed\_seed\_message$ and carry out the following calculations:
 \begin{algorithmic}
\State $aggregate\_seed\_message =$ \\ $= seed\_message \  \text{(from Player1)} \ ||  \ seed\_message \  \text{(from Player2)}$
\State $V = H(aggregate\_seed\_message)$
\State $S =  \tau .PartSign(V)$
 \end{algorithmic}
\item Then they exchange messages with their respective signature fragments.
\begin{center}
 $message = (S, round, gameData, player1Balance, player2Balance)$
\end{center}
	\item Players verify whether the S number is calculated correctly. If the condition is met, the next step follows.
	\item To compute the game results, the players holding two segments of the signature merge them into a single $aggregate\_S$ that depends on the selected  $\tau$ and on the DKG protocol.
\begin{algorithmic}
\State $S_{hash} = H(aggregate\_S)$
\State $gameRange = maxGame -  minGame + 1$
\While {$S_{hash} \geq \left\lfloor 2^{hash.size} / gameRange \right\rfloor \cdot gameRange$}
\State$ S_{hash}\gets H(aggregate\_S_{hash})$
\EndWhile
\State $L = (S_{hash}$ mod $gameRange) + minGame$
\end{algorithmic}
\end{enumerate}
\end{algorithm}
\begin{algorithm}
\begin{enumerate}
\setcounter{enumi}{5}
 \item Players exchange obtained game results and verify the data. 
\begin{center}
 $message = (channelId, round, gameData, player1Balance, player2Balance)$
 $signed\_message = ECDSA.Sign(message)$
\end{center}
\item If needed, either player may use the two signatures of the result message to update the channel state.
\end{enumerate}
\end{algorithm}

To close a channel, same methods are used as specified in \autoref{closing}. The protocols covered in that section are compatible with this modification with minor alteration. Now bet is considered made once both participants posted their seeds. Also the  $resolveDispute$ and $doubleSign$ functions are available to either participants. (see the \ref{block} item for protocol 6). 

\subsection{Third Party Observer}

The above mentioned Pisa \cite{bib9} allows connecting a third watcher to a channel. If one of the actual players happens to get disconnected, the watcher will be able to represent that player before the smart contract. Game channels’ design allows easily applying a similar approach to them and connecting a third participant. To that end, any time participants approve some state, they post it with their respective signatures. The third participant listens to the channel and can then update the smart contract state using these messages. Note that the third participants needs no lock or verification at the game smart contract. 

This approach could be useful in a design of a platform where players and dealers meet. In this case a platform can assume responsibility for all contract requests reducing player costs incurred from additional transactions. Yet, the downside of the approach is increased system centralization. Anyway, requests to smart contracts via the platform can be implemented as an optional, not mandatory functionality.

